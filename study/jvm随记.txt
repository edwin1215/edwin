
JVM原理

第二章 java内存区域

运行时数据区域
1、程序计数器
2、虚拟机栈
	栈帧：
		局部变量表
		操作数栈
		动态链接
		方法返回地址
		额外的附加信息
3、本地方法栈
4、java堆
5、方法区
	运行时常量池
	Class对象（类信息，如局部变量表）
	JIT编译后的代码
6、直接内存


第六、七章

Class文件结构

两种数据类型(类似于C语言结构体的伪结构)
	无符号数：u1、u2、u4、u8代表1byte、2byte、4byte、8byte
	表：由多个无符号数或者其他表作为数据项构成复合数据结构，所有表习惯以.info结尾


1、魔数（Magic Number）、次版本（Minor Version）、主版本（Major Version）
2、常量池（Constant Pool）
	a、字面量(Literal)：如文本字符串、常量值(final)
	b、符号引用(Symbolic References)
		类和接口的全限定名(Fully Qualified Name)
		字段的名称和描述符(Descriptor)
		方法的名称和描述符(Descriptor)
	
	14种表结构
	javap -v xxx.class //查看字节码内容
	如：CONSTANT_Utf8_info
	
3、访问标志（access_flags）
	class or interface
	public private protected default
	是否abstract
	是否final
	
	如：ACC_PUBLIC

4、类索引、父类索引与接口索引集合
	类索引：	this_class		u2
	父类索引：	super_class		u2
	接口索引：	interfaces		u2集合	入口第一项：u2的接口计数器(interfaces_count)

5、字段表集合（field_info）
	描述类中的变量：类变量、实例变量
	描述信息：
		作用域(public、private...)			boolean
		实例or类变量(static)				boolean
		可变性(final)						boolean
		并发可见性(volatile)				boolean
		可否被序列化(transient)				boolean
		数据类型(基本类型、对象、数组)		引用常量池中的常量
		字段名称							引用常量池中的常量
	
	结构：
		u2					access_flags			访问标志（类似class中的访问标志）
		u2					name_index				简单名称
		u2					descriptor_index		方法描述符
		u2					attributes_count		
		attribute_info		attributes				attributes_count个

	简单名称：main() -> main，int m -> m
	描述符：描述字段的数据类型、方法参数、返回值
		如：[[Ljava/lang/String  -> String[][]
	全限定名：com.edwin.test -> com/edwin/test;
	
6、方法表集合（method_info）
	基本同上
	access_flags有区别
		减少：volatile、transient
		增加：synchronized、native、strictfp、abstract

7、属性表集合（attribute_info）
	1）Code属性（方法体中的代码）
		attribute_name_index		Code
		attribute_length			属性值的长度
		max_statck					操作数栈最大深度
		max_locals					局部变量表存储空间（单位是Slot，1Slot = 32Bit = 4Byte）
		code_length					源程序编译成字节码后长度
		code						字节码
		
	2）Exception属性
		记录受查异常
	3）LineNumberTable属性
		源码行号和字节码行号(偏移量)对应关系
	4）LocalVariableTable属性
		描述栈帧中局部变量表中的变量和java源码中定义的变量之间的关系
	5）SourceFile属性
		记录Class文件的源码文件名称（关闭时打印堆栈信息时不显示类名）
	6）ConstantValue属性
		通知虚拟机自动为static变量赋值（包括但不仅仅是final）
	7）InnerClasses属性
		记录内部类和宿主类的关联
	8）Deprecated及Synthetic属性
		不推荐使用、非java源码产生而是由编译器自行添加的
	9）StackMapTable属性
		
	10）Signature属性
		
	11）BootstrapMethods属性
		用户保存invokedynamic指令引用的引导方法限定符

字节码指令
1、加载和存储指令
	用于将数据在栈帧中的局部变量表和操作数栈之间来回传输
	（T代表数据类型）
	1）局部变量表---加载--->操作数栈：Tload、Tload_<n>
	2）操作数栈---存储--->局部变量表：Tstore、Tstore_<n>
	3）常量---加载--->操作数栈：Tipush、Tconst、Tconst_<T>、aconst_null、ldc、ldc_w
	4）扩充局部变量表的访问索引：wide

2、运算指令
	用于对两个操作数栈上的值进行运算，并把结果存入操作数栈顶
	大体分两种：
		a、整型数据运算指令符
		b、浮点型数据运算指令符
	没有直接支持byte、short、char、boolean的运算指令
	（T代表数据类型：i-int、l-long、f-float、d-double）
	1）加法：Tadd
	2）减法：Tsub
	3）乘法：Tmul
	4）除法：Tdiv
	5）求余：Trem
	6）取反：Tneg
	7）位移：Tshl-左移、Tshr-右移、Tushr-无符号右移（int、long）
	8）按位或：Tor（int、long）
	9）按位与：Tand（int、long）
	10）按位异：Txor（int、long）
	11）局部变量自增：iinc
	12）比较：dcmpg、dcmpl、fcmpg、fcmpl、lcmp
	只有除法指令(Tdiv)和求余指令(Trem)中，出现除数为0时-->ArithmeticException

3、类型转换指令
	T2U
	
4、对象创建与访问指令
	1）创建对象：new
	2）创建数组对象：newarray、anewarray、multianewarray
	3）访问类字段、实例字段：getfield、putfield、getstatic、putstatic
	4）把数组元素---加载--->操作数栈：Taload
	5）操作数栈---存储--->数组元素：Tastore
	6）获取数组长度：arraylength
	7）检查对象类型：instanceof、checkcast 

5、操作数栈管理指令
	1）将操作数栈顶的一个或两个元素出栈：pop、pop2
	2）复制栈顶的一个或两个数值，将一份或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2
	3）将栈顶两个数值互换：swap

6、控制转移指令
	1）条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne...
	2）复合条件分支：tableswitch、lookupswitch
	3）无条件分支：goto、goto_w、jsr、jsr_w、ret
	
7、方法调用和返回指令
	1）invokevirtual：调用对象的实例方法，根据对象的实际类型进行分派
	2）invokeinterface：用于调用接口方法
	3）invokespecial：用于调用一些需要特殊处理的实例方法，如：对象初始化方法、私有方法、父类方法
	4）invokestatic：调用类方法
	5）invokedynamic：在运行时动态解析出调用点限定符所引用的方法

8、异常处理指令
	athrow

9、同步指令
	synchronized：monitorenter、monitorexit


类的加载过程

1、加载load
	a、通过一个类的全限定名来获取定义此类的二进制字节流
	b、将二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构
	c、在内存中生成java.lang.Class对象，作为方法区类的各种数据的访问入口
2、验证
	a、文件格式验证
	b、元数据验证
	c、字节码验证
	d、符号引用验证
3、准备
	为类变量在方法区分配内存并设置其初始值(零值)
	如果类变量的字段属性表中存在ConstantValue属性(final)，初始化为指定值
4、解析
	将常量池中的符号引用替换为直接引用
		符号引用(Symbolic References)：
		直接引用(Direct References)：
5、初始化
	编译器自动生成<clinit>方法：
		a、类变量赋值、静态语句块
		b、虚拟机优先执行父类的<clinit>方法
		c、不是必须，如果没有类变量、静态代码块则编译器不会生成<clinit>方法
		d、接口的<clinit>方法不必须调用父类的<clinit>方法，只有父接口有类变量时，父接口才会初始化
		e、<clinit>方法只会被调用一次，多线程下虚拟机会保证<clinit>方法的线程安全，其他线程阻塞

类加载器

1、启动类加载器（Bootstrap ClassLoader）
	用于加载<JAVA_HOME>\lib目录、或者-Xbootclasspath参数指定的路径下，虚拟机识别的类库；
	HotSpot虚拟机是用C++实现的
2、扩展类加载器（Extension ClassLoader）
	用于加载<JAVA_HOME>\lib\ext目录、或者java.ext.dirs系统变量所指定的路径下的所有类库
3、应用程序类加载器（Application ClassLoader）
	用户加载用户路径（ClassPath）下的类库
	ClassLoader中getSystemClassLoader()获取，又称系统类加载器

双亲委派机制
	自定义类加载器
		即使不使用双亲委派模型，编写rt.jar包中的java类，强行使用defineClass()方法依然不会成功，会抛出SecurityException
	三次破坏
		1、JDK1.2之前双亲委派模型未被引入
		2、JNDI、JDBC、JCE、JAXB、JBI等技术需要rt.jar这些核心库的基础类(引导类加载器)的回调SPI（Service Provider Interface）(系统类加载器)，引入了线程上下文类加载器（默认系统类加载器）
		3、由于用户对程序动态性的追求而导致，代码热替换（HotSwap）、模块热部署（Hot Deployment）等。OSGi




第八章 虚拟机字节码执行引擎


解释执行（通过解释器执行）、编译执行（通过JIT产生本地代码执行）

运行时虚拟机栈结构
	虚拟机栈由栈帧和本地变量表组成。是方法执行的内存模型
	
1、局部变量表
	单位：slot，1slot=32bit=4byte
	方法参数、局部变量
	执行实例方法时，局部变量表第0个slot默认用户传递当前类实例引用
	
	
2、操作数栈
3、动态链接
4、方法返回地址




第十、十一章 编译器、运行期优化

语法糖
	计算机语言中添加的某种语法，对功能并没有影响，但是更方便使用
1、泛型与类型擦除
	泛型的本质是参数化类型的应用
	java用类型擦除的方式来实现泛型




第十二章 Java内存模型与线程
